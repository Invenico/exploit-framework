package dispatcher

import (
	"bytes"
	"fmt"
	"github.com/WangYihang/readline"
	"github.com/sirupsen/logrus"
	"os/exec"
	"runtime"
	"strings"
)

type Dispatcher struct{}

var ReadLineInstance *readline.Instance

func System(command string) (error, string, string) {
	var stdout bytes.Buffer
	var stderr bytes.Buffer
	os := runtime.GOOS
	switch os {
	case "windows":
		cmd := exec.Command("cmd", "/C", command)
		cmd.Stdout = &stdout
		cmd.Stderr = &stderr
		err := cmd.Run()
		return err, stdout.String(), stderr.String()
	case "darwin":
		cmd := exec.Command("/bin/sh", "-c", command)
		cmd.Stdout = &stdout
		cmd.Stderr = &stderr
		err := cmd.Run()
		return err, stdout.String(), stderr.String()
	case "linux":
		cmd := exec.Command("/bin/sh", "-c", command)
		cmd.Stdout = &stdout
		cmd.Stderr = &stderr
		err := cmd.Run()
		return err, stdout.String(), stderr.String()
	default:
		return fmt.Errorf("Unsupported OS type: %s", os), "", ""
	}
}

// parse inputs
func parseInput(input string) (string, []string) {
	methods := reflection.GetAllMethods(Dispatcher{})
	args := strings.Split(strings.TrimSpace(input), " ")
	if len(args[0]) == 0 {
		return "", []string{}
	}

	target := ""
	for _, method := range methods {
		if strings.ToLower(method) == strings.ToLower(args[0]) {
			target = method

			break
		}
	}

	if target != "" {
		return target, args[1:]
	} else {
		log.Error("No such command, use `Help` to get more information")
		_, stdout, _ := System(input)
		log.Info("Executing locally: %s", input)
		fmt.Printf(stdout)
		return "", []string{}
	}
}

// filter input
func filterInput(r rune) (rune, bool) {
	switch r {
	case readline.CharCtrlZ:
		return r, false

	}
	return r, true
}